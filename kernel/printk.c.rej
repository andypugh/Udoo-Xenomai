***************
*** 713,718 ****
  	return 0;
  }
  
  /**
   * printk - print a kernel message
   * @fmt: format string
--- 713,753 ----
  	return 0;
  }
  
+ #ifdef CONFIG_IPIPE
+ 
+ static IPIPE_DEFINE_SPINLOCK(__ipipe_printk_lock);
+ 
+ static int __ipipe_printk_fill;
+ 
+ static char __ipipe_printk_buf[__LOG_BUF_LEN];
+ 
+ void __ipipe_flush_printk (unsigned virq, void *cookie)
+ {
+ 	char *p = __ipipe_printk_buf;
+ 	int len, lmax, out = 0;
+ 	unsigned long flags;
+ 
+ 	goto start;
+ 
+ 	do {
+ 		spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
+  start:
+ 		lmax = __ipipe_printk_fill;
+ 		while (out < lmax) {
+ 			len = strlen(p) + 1;
+ 			printk("%s",p);
+ 			p += len;
+ 			out += len;
+ 		}
+ 		spin_lock_irqsave(&__ipipe_printk_lock, flags);
+ 	}
+ 	while (__ipipe_printk_fill != lmax);
+ 
+ 	__ipipe_printk_fill = 0;
+ 
+ 	spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
+ }
+ 
  /**
   * printk - print a kernel message
   * @fmt: format string
***************
*** 737,742 ****
  
  asmlinkage int printk(const char *fmt, ...)
  {
  	va_list args;
  	int r;
  
--- 772,839 ----
  
  asmlinkage int printk(const char *fmt, ...)
  {
+ 	int r, fbytes, oldcount;
+ 	unsigned long flags;
+ 	int sprintk = 1;
+ 	int cs = -1;
+ 	va_list args;
+ 
+ 	va_start(args, fmt);
+ 
+ 	local_irq_save_hw(flags);
+ 
+ 	if (test_bit(IPIPE_SPRINTK_FLAG, &__ipipe_current_domain->flags) ||
+ 	    oops_in_progress)
+ 		cs = ipipe_disable_context_check(ipipe_processor_id());
+ 	else if (__ipipe_root_domain_p) {
+ 		struct ipipe_domain *dom;
+ 
+ 		list_for_each_entry(dom, &__ipipe_pipeline, p_link) {
+ 			if (dom == ipipe_root_domain)
+ 				break;
+ 			if (test_bit(IPIPE_STALL_FLAG,
+ 				     &ipipe_cpudom_var(dom, status))
+ 			    || raw_irqs_disabled_flags(flags)) {
+ 				sprintk = 0;
+ 				break;
+ 			}
+ 		}
+ 	} else
+ 		sprintk = 0;
+ 
+ 	local_irq_restore_hw(flags);
+ 
+ 	if (sprintk) {
+ 		r = vprintk(fmt, args);
+ 		if (cs != -1)
+ 			ipipe_restore_context_check(ipipe_processor_id(), cs);
+ 		goto out;
+ 	}
+ 
+ 	spin_lock_irqsave(&__ipipe_printk_lock, flags);
+ 
+ 	oldcount = __ipipe_printk_fill;
+ 	fbytes = __LOG_BUF_LEN - oldcount;
+ 
+ 	if (fbytes > 1)	{
+ 		r = vscnprintf(__ipipe_printk_buf + __ipipe_printk_fill,
+ 			       fbytes, fmt, args) + 1; /* account for the null byte */
+ 		__ipipe_printk_fill += r;
+ 	} else
+ 		r = 0;
+ 
+ 	spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
+ 
+ 	if (oldcount == 0)
+ 		ipipe_trigger_irq(__ipipe_printk_virq);
+ out:
+ 	va_end(args);
+ 
+ 	return r;
+ }
+ #else /* !CONFIG_IPIPE */
+ asmlinkage int printk(const char *fmt, ...)
+ {
  	va_list args;
  	int r;
  
***************
*** 754,759 ****
  
  	return r;
  }
  
  /* cpu currently holding logbuf_lock */
  static volatile unsigned int printk_cpu = UINT_MAX;
--- 851,857 ----
  
  	return r;
  }
+ #endif /* CONFIG_IPIPE */
  
  /* cpu currently holding logbuf_lock */
  static volatile unsigned int printk_cpu = UINT_MAX;
***************
*** 949,955 ****
  	 * Try to acquire and then immediately release the
  	 * console semaphore. The release will do all the
  	 * actual magic (print out buffers, wake up klogd,
- 	 * etc). 
  	 *
  	 * The console_trylock_for_printk() function
  	 * will release 'logbuf_lock' regardless of whether it
--- 1047,1053 ----
  	 * Try to acquire and then immediately release the
  	 * console semaphore. The release will do all the
  	 * actual magic (print out buffers, wake up klogd,
+ 	 * etc).
  	 *
  	 * The console_trylock_for_printk() function
  	 * will release 'logbuf_lock' regardless of whether it
***************
*** 1545,1551 ****
  
  int unregister_console(struct console *console)
  {
-         struct console *a, *b;
  	int res = 1;
  
  #ifdef CONFIG_A11Y_BRAILLE_CONSOLE
--- 1643,1649 ----
  
  int unregister_console(struct console *console)
  {
+ 	struct console *a, *b;
  	int res = 1;
  
  #ifdef CONFIG_A11Y_BRAILLE_CONSOLE
