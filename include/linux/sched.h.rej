***************
*** 62,67 ****
  #include <linux/errno.h>
  #include <linux/nodemask.h>
  #include <linux/mm_types.h>
  
  #include <asm/system.h>
  #include <asm/page.h>
--- 62,68 ----
  #include <linux/errno.h>
  #include <linux/nodemask.h>
  #include <linux/mm_types.h>
+ #include <linux/ipipe.h>
  
  #include <asm/system.h>
  #include <asm/page.h>
***************
*** 191,199 ****
  #define TASK_DEAD		64
  #define TASK_WAKEKILL		128
  #define TASK_WAKING		256
  #define TASK_STATE_MAX		512
- 
  #define TASK_STATE_TO_CHAR_STR "RSDTtZXxKW"
  
  extern char ___assert_task_state[1 - 2*!!(
  		sizeof(TASK_STATE_TO_CHAR_STR)-1 != ilog2(TASK_STATE_MAX)+1)];
--- 192,208 ----
  #define TASK_DEAD		64
  #define TASK_WAKEKILL		128
  #define TASK_WAKING		256
+ #ifdef CONFIG_IPIPE
+ #define TASK_ATOMICSWITCH	512
+ #define TASK_NOWAKEUP		1024
+ #define TASK_STATE_MAX		2048
+ #define TASK_STATE_TO_CHAR_STR "RSDTtZXxKWAN"
+ #else  /* !CONFIG_IPIPE */
+ #define TASK_ATOMICSWITCH	0
+ #define TASK_NOWAKEUP		0
  #define TASK_STATE_MAX		512
  #define TASK_STATE_TO_CHAR_STR "RSDTtZXxKW"
+ #endif /* CONFIG_IPIPE */
  
  extern char ___assert_task_state[1 - 2*!!(
  		sizeof(TASK_STATE_TO_CHAR_STR)-1 != ilog2(TASK_STATE_MAX)+1)];
***************
*** 305,310 ****
  extern void update_process_times(int user);
  extern void scheduler_tick(void);
  
  extern void sched_show_task(struct task_struct *p);
  
  #ifdef CONFIG_LOCKUP_DETECTOR
--- 314,328 ----
  extern void update_process_times(int user);
  extern void scheduler_tick(void);
  
+ #ifdef CONFIG_IPIPE
+ void update_root_process_times(struct pt_regs *regs);
+ #else  /* !CONFIG_IPIPE */
+ static inline void update_root_process_times(struct pt_regs *regs)
+ {
+ 	update_process_times(user_mode(regs));
+ }
+ #endif /* CONFIG_IPIPE */
+ 
  extern void sched_show_task(struct task_struct *p);
  
  #ifdef CONFIG_LOCKUP_DETECTOR
***************
*** 358,364 ****
  extern signed long schedule_timeout_interruptible(signed long timeout);
  extern signed long schedule_timeout_killable(signed long timeout);
  extern signed long schedule_timeout_uninterruptible(signed long timeout);
- asmlinkage void schedule(void);
  extern int mutex_spin_on_owner(struct mutex *lock, struct task_struct *owner);
  
  struct nsproxy;
--- 376,382 ----
  extern signed long schedule_timeout_interruptible(signed long timeout);
  extern signed long schedule_timeout_killable(signed long timeout);
  extern signed long schedule_timeout_uninterruptible(signed long timeout);
+ asmlinkage int schedule(void);
  extern int mutex_spin_on_owner(struct mutex *lock, struct task_struct *owner);
  
  struct nsproxy;
***************
*** 435,440 ****
  					/* leave room for more dump flags */
  #define MMF_VM_MERGEABLE	16	/* KSM may merge identical pages */
  #define MMF_VM_HUGEPAGE		17	/* set when VM_HUGEPAGE is set on vma */
  
  #define MMF_INIT_MASK		(MMF_DUMPABLE_MASK | MMF_DUMP_FILTER_MASK)
  
--- 453,461 ----
  					/* leave room for more dump flags */
  #define MMF_VM_MERGEABLE	16	/* KSM may merge identical pages */
  #define MMF_VM_HUGEPAGE		17	/* set when VM_HUGEPAGE is set on vma */
+ #ifdef CONFIG_IPIPE
+ #define MMF_VM_PINNED		31	/* ondemand load up and COW disabled */
+ #endif
  
  #define MMF_INIT_MASK		(MMF_DUMPABLE_MASK | MMF_DUMP_FILTER_MASK)
  
***************
*** 1313,1321 ****
  	unsigned long stack_canary;
  #endif
  
- 	/* 
  	 * pointers to (original) parent process, youngest child, younger sibling,
- 	 * older sibling, respectively.  (p->father can be replaced with 
  	 * p->real_parent->pid)
  	 */
  	struct task_struct *real_parent; /* real parent process */
--- 1334,1342 ----
  	unsigned long stack_canary;
  #endif
  
+ 	/*
  	 * pointers to (original) parent process, youngest child, younger sibling,
+ 	 * older sibling, respectively.  (p->father can be replaced with
  	 * p->real_parent->pid)
  	 */
  	struct task_struct *real_parent; /* real parent process */
***************
*** 1514,1519 ****
  #endif
  	atomic_t fs_excl;	/* holding fs exclusive resources */
  	struct rcu_head rcu;
  
  	/*
  	 * cache last used pipe for splice
--- 1535,1544 ----
  #endif
  	atomic_t fs_excl;	/* holding fs exclusive resources */
  	struct rcu_head rcu;
+ #ifdef CONFIG_IPIPE
+ 	unsigned int ipipe_flags;
+ 	void *ptd[IPIPE_ROOT_NPTDKEYS];
+ #endif
  
  	/*
  	 * cache last used pipe for splice
***************
*** 1787,1792 ****
  #define PF_FREEZER_SKIP	0x40000000	/* Freezer should not count it as freezable */
  #define PF_FREEZER_NOSIG 0x80000000	/* Freezer won't send signals to it */
  
  /*
   * Only the _current_ task can read/write to tsk->flags, but other
   * tasks can access tsk->flags in readonly mode for example
--- 1812,1821 ----
  #define PF_FREEZER_SKIP	0x40000000	/* Freezer should not count it as freezable */
  #define PF_FREEZER_NOSIG 0x80000000	/* Freezer won't send signals to it */
  
+ /* p->ipipe_flags */
+ #define PF_EVTRET	0x1	/* EVENT_RETURN is pending */
+ #define PF_EVNOTIFY	0x2	/* Notify other domains about internal events */
+ 
  /*
   * Only the _current_ task can read/write to tsk->flags, but other
   * tasks can access tsk->flags in readonly mode for example
***************
*** 2135,2141 ****
  	spin_unlock_irqrestore(&tsk->sighand->siglock, flags);
  
  	return ret;
- }	
  
  extern void block_all_signals(int (*notifier)(void *priv), void *priv,
  			      sigset_t *mask);
--- 2164,2170 ----
  	spin_unlock_irqrestore(&tsk->sighand->siglock, flags);
  
  	return ret;
+ }
  
  extern void block_all_signals(int (*notifier)(void *priv), void *priv,
  			      sigset_t *mask);
