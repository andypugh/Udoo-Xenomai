***************
*** 21,26 ****
  #include <linux/io.h>
  #include <linux/slab.h>
  #include <linux/pm_runtime.h>
  
  #include <mach/hardware.h>
  #include <asm/irq.h>
--- 21,27 ----
  #include <linux/io.h>
  #include <linux/slab.h>
  #include <linux/pm_runtime.h>
+ #include <linux/ipipe.h>
  
  #include <mach/hardware.h>
  #include <asm/irq.h>
***************
*** 46,52 ****
  	u32 saved_risingdetect;
  	u32 level_mask;
  	u32 toggle_mask;
- 	spinlock_t lock;
  	struct gpio_chip chip;
  	struct clk *dbck;
  	u32 mod_usage;
--- 47,53 ----
  	u32 saved_risingdetect;
  	u32 level_mask;
  	u32 toggle_mask;
+ 	ipipe_spinlock_t lock;
  	struct gpio_chip chip;
  	struct clk *dbck;
  	u32 mod_usage;
***************
*** 54,59 ****
  	struct device *dev;
  	bool dbck_flag;
  	int stride;
  };
  
  #ifdef CONFIG_ARCH_OMAP3
--- 55,63 ----
  	struct device *dev;
  	bool dbck_flag;
  	int stride;
+ #ifdef CONFIG_IPIPE
+ 	unsigned nonroot_gpios;
+ #endif
  };
  
  #ifdef CONFIG_ARCH_OMAP3
***************
*** 73,78 ****
  static struct omap3_gpio_regs gpio_context[OMAP34XX_NR_GPIOS];
  #endif
  
  /*
   * TODO: Cleanup gpio_bank usage as it is having information
   * related to all instances of the device
--- 77,88 ----
  static struct omap3_gpio_regs gpio_context[OMAP34XX_NR_GPIOS];
  #endif
  
+ #if !defined(MULTI_OMAP1) && !defined(MULTI_OMAP2)
+ #define inline_single inline
+ #else
+ #define inline_single
+ #endif
+ 
  /*
   * TODO: Cleanup gpio_bank usage as it is having information
   * related to all instances of the device
***************
*** 84,89 ****
  /* TODO: Analyze removing gpio_bank_count usage from driver code */
  int gpio_bank_count;
  
  static inline struct gpio_bank *get_gpio_bank(int gpio)
  {
  	if (cpu_is_omap15xx()) {
--- 94,105 ----
  /* TODO: Analyze removing gpio_bank_count usage from driver code */
  int gpio_bank_count;
  
+ #ifdef CONFIG_IPIPE
+ #ifdef __IPIPE_FEATURE_PIC_MUTE
+ DEFINE_PER_CPU(__ipipe_irqbits_t, __ipipe_muted_irqs);
+ #endif /* __IPIPE_FEATURE_PIC_MUTE */
+ #endif /* CONFIG_IPIPE */
+ 
  static inline struct gpio_bank *get_gpio_bank(int gpio)
  {
  	if (cpu_is_omap15xx()) {
***************
*** 144,150 ****
  	return -1;
  }
  
- static int check_gpio(int gpio)
  {
  	if (unlikely(gpio_valid(gpio) < 0)) {
  		printk(KERN_ERR "omap-gpio: invalid GPIO %d\n", gpio);
--- 160,166 ----
  	return -1;
  }
  
+ static inline_single int check_gpio(int gpio)
  {
  	if (unlikely(gpio_valid(gpio) < 0)) {
  		printk(KERN_ERR "omap-gpio: invalid GPIO %d\n", gpio);
***************
*** 501,507 ****
   * This only applies to chips that can't do both rising and falling edge
   * detection at once.  For all other chips, this function is a noop.
   */
- static void _toggle_gpio_edge_triggering(struct gpio_bank *bank, int gpio)
  {
  	void __iomem *reg = bank->base;
  	u32 l = 0;
--- 517,523 ----
   * This only applies to chips that can't do both rising and falling edge
   * detection at once.  For all other chips, this function is a noop.
   */
+ static inline_single void _toggle_gpio_edge_triggering(struct gpio_bank *bank, int gpio)
  {
  	void __iomem *reg = bank->base;
  	u32 l = 0;
***************
*** 534,540 ****
  }
  #endif
  
- static int _set_gpio_triggering(struct gpio_bank *bank, int gpio, int trigger)
  {
  	void __iomem *reg = bank->base;
  	u32 l = 0;
--- 550,556 ----
  }
  #endif
  
+ static inline_single int _set_gpio_triggering(struct gpio_bank *bank, int gpio, int trigger)
  {
  	void __iomem *reg = bank->base;
  	u32 l = 0;
***************
*** 653,659 ****
  	return retval;
  }
  
- static void _clear_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)
  {
  	void __iomem *reg = bank->base;
  
--- 669,675 ----
  	return retval;
  }
  
+ static inline_single void _clear_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)
  {
  	void __iomem *reg = bank->base;
  
***************
*** 714,720 ****
  	_clear_gpio_irqbank(bank, 1 << get_gpio_index(gpio));
  }
  
- static u32 _get_gpio_irqbank_mask(struct gpio_bank *bank)
  {
  	void __iomem *reg = bank->base;
  	int inv = 0;
--- 730,736 ----
  	_clear_gpio_irqbank(bank, 1 << get_gpio_index(gpio));
  }
  
+ static inline_single u32 _get_gpio_irqbank_mask(struct gpio_bank *bank)
  {
  	void __iomem *reg = bank->base;
  	int inv = 0;
***************
*** 773,779 ****
  	return l;
  }
  
- static void _enable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask, int enable)
  {
  	void __iomem *reg = bank->base;
  	u32 l;
--- 789,795 ----
  	return l;
  }
  
+ static inline_single void _enable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask, int enable)
  {
  	void __iomem *reg = bank->base;
  	u32 l;
***************
*** 1008,1013 ****
  	spin_unlock_irqrestore(&bank->lock, flags);
  }
  
  /*
   * We need to unmask the GPIO bank interrupt as soon as possible to
   * avoid missing GPIO interrupts for other lines in the bank.
--- 1024,1030 ----
  	spin_unlock_irqrestore(&bank->lock, flags);
  }
  
+ 
  /*
   * We need to unmask the GPIO bank interrupt as soon as possible to
   * avoid missing GPIO interrupts for other lines in the bank.
***************
*** 1019,1031 ****
   */
  static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
  {
- 	void __iomem *isr_reg = NULL;
- 	u32 isr;
  	unsigned int gpio_irq, gpio_index;
  	struct gpio_bank *bank;
  	u32 retrigger = 0;
  	int unmasked = 0;
- 	struct irq_chip *chip = irq_desc_get_chip(desc);
  
  	chained_irq_enter(chip, desc);
  
--- 1036,1048 ----
   */
  static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
  {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
  	unsigned int gpio_irq, gpio_index;
+ 	void __iomem *isr_reg = NULL;
  	struct gpio_bank *bank;
  	u32 retrigger = 0;
  	int unmasked = 0;
+ 	u32 isr;
  
  	chained_irq_enter(chip, desc);
  
***************
*** 1100,1117 ****
  				continue;
  
  #ifdef CONFIG_ARCH_OMAP1
- 			/*
- 			 * Some chips can't respond to both rising and falling
- 			 * at the same time.  If this irq was requested with
- 			 * both flags, we need to flip the ICR data for the IRQ
- 			 * to respond to the IRQ for the opposite direction.
- 			 * This will be indicated in the bank toggle_mask.
- 			 */
  			if (bank->toggle_mask & (1 << gpio_index))
  				_toggle_gpio_edge_triggering(bank, gpio_index);
  #endif
- 
- 			generic_handle_irq(gpio_irq);
  		}
  	}
  	/* if bank has any level sensitive GPIO pin interrupt
--- 1117,1133 ----
  				continue;
  
  #ifdef CONFIG_ARCH_OMAP1
+ 		/*
+ 		 * Some chips can't respond to both rising and falling
+ 		 * at the same time.  If this irq was requested with
+ 		 * both flags, we need to flip the ICR data for the IRQ
+ 		 * to respond to the IRQ for the opposite direction.
+ 		 * This will be indicated in the bank toggle_mask.
+ 		 */
  			if (bank->toggle_mask & (1 << gpio_index))
  				_toggle_gpio_edge_triggering(bank, gpio_index);
  #endif
+ 			ipipe_handle_chained_irq(gpio_irq);
  		}
  	}
  	/* if bank has any level sensitive GPIO pin interrupt
***************
*** 1154,1159 ****
  	spin_unlock_irqrestore(&bank->lock, flags);
  }
  
  static void gpio_unmask_irq(struct irq_data *d)
  {
  	unsigned int gpio = d->irq - IH_GPIO_BASE;
--- 1170,1188 ----
  	spin_unlock_irqrestore(&bank->lock, flags);
  }
  
+ static void gpio_mask_ack_irq(struct irq_data *d)
+ {
+ 	unsigned int gpio = d->irq - IH_GPIO_BASE;
+ 	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&bank->lock, flags);
+ 	_set_gpio_irqenable(bank, gpio, 0);
+ 	_set_gpio_triggering(bank, get_gpio_index(gpio), IRQ_TYPE_NONE);
+ 	spin_unlock_irqrestore(&bank->lock, flags);
+ 	_clear_gpio_irqstatus(bank, gpio);
+ }
+ 
  static void gpio_unmask_irq(struct irq_data *d)
  {
  	unsigned int gpio = d->irq - IH_GPIO_BASE;
***************
*** 1182,1187 ****
  	.irq_shutdown	= gpio_irq_shutdown,
  	.irq_ack	= gpio_ack_irq,
  	.irq_mask	= gpio_mask_irq,
  	.irq_unmask	= gpio_unmask_irq,
  	.irq_set_type	= gpio_irq_type,
  	.irq_set_wake	= gpio_wake_enable,
--- 1211,1217 ----
  	.irq_shutdown	= gpio_irq_shutdown,
  	.irq_ack	= gpio_ack_irq,
  	.irq_mask	= gpio_mask_irq,
+ 	.irq_mask_ack	= gpio_mask_ack_irq,
  	.irq_unmask	= gpio_unmask_irq,
  	.irq_set_type	= gpio_irq_type,
  	.irq_set_wake	= gpio_wake_enable,
***************
*** 1570,1575 ****
  		irq_set_handler(j, handle_simple_irq);
  		set_irq_flags(j, IRQF_VALID);
  	}
  	irq_set_chained_handler(bank->irq, gpio_irq_handler);
  	irq_set_handler_data(bank->irq, bank);
  }
--- 1600,1611 ----
  		irq_set_handler(j, handle_simple_irq);
  		set_irq_flags(j, IRQF_VALID);
  	}
+ 
+ #if defined(CONFIG_IPIPE) && defined(__IPIPE_FEATURE_PIC_MUTE)
+ 	__ipipe_irqbits[1 << (bank->irq / 32)]
+ 		|= (1 << (bank->irq % 32));
+ #endif
+ 
  	irq_set_chained_handler(bank->irq, gpio_irq_handler);
  	irq_set_handler_data(bank->irq, bank);
  }
***************
*** 1640,1645 ****
  	return 0;
  }
  
  #if defined(CONFIG_ARCH_OMAP16XX) || defined(CONFIG_ARCH_OMAP2PLUS)
  static int omap_gpio_suspend(void)
  {
--- 1676,1846 ----
  	return 0;
  }
  
+ #if defined(CONFIG_IPIPE) && defined(__IPIPE_FEATURE_PIC_MUTE)
+ 
+ extern void omap2_intc_mute(void);
+ extern void omap2_intc_unmute(void);
+ extern void omap3_intc_mute(void);
+ extern void omap3_intc_unmute(void);
+ extern void omap3_intc_set_irq_prio(int irq, int hi);
+ extern void gic_mute(void);
+ extern void gic_unmute(void);
+ extern void gic_set_irq_prio(int irq, int hi);
+ 
+ void __ipipe_mach_pic_set_irq_prio(int irq, int hi)
+ {
+ #if defined(CONFIG_ARCH_OMAP3)
+ 	if (cpu_is_omap34xx())
+ 		omap3_intc_set_irq_prio(irq, hi);
+ #endif /* OMAP3 */
+ #if defined(CONFIG_ARCH_OMAP4)
+ 	if (cpu_is_omap44xx())
+ 		gic_set_irq_prio(irq, hi);
+ #endif /* OMAP4 */
+ }
+ 
+ /* Multi OMAP2: run-time selection */
+ #ifdef MULTI_OMAP2
+ void __ipipe_mach_pic_mute(void)
+ {
+ #if defined(CONFIG_ARCH_OMAP2420) || defined (CONFIG_ARM_OMAP2430)
+ 	if (cpu_is_omap24xx())
+ 		omap2_intc_mute();
+ #endif /* OMAP2 */
+ #if defined(CONFIG_ARCH_OMAP3)
+ 	if (cpu_is_omap34xx())
+ 		omap3_intc_mute();
+ #endif /* OMAP3 */
+ #if defined(CONFIG_ARCH_OMAP4)
+ 	if (cpu_is_omap44xx())
+ 		gic_mute();
+ #endif /* OMAP4 */
+ }
+ 
+ void __ipipe_mach_pic_unmute(void)
+ {
+ #if defined(CONFIG_ARCH_OMAP2420) || defined (CONFIG_ARM_OMAP2430)
+ 	if (cpu_is_omap24xx())
+ 		omap2_intc_unmute();
+ #endif /* OMAP2 */
+ #if defined(CONFIG_ARCH_OMAP3)
+ 	if (cpu_is_omap34xx())
+ 		omap3_intc_unmute();
+ #endif /* OMAP3 */
+ #if defined(CONFIG_ARCH_OMAP4)
+ 	if (cpu_is_omap44xx())
+ 		gic_unmute();
+ #endif /* OMAP4 */
+ }
+ 
+ /* OMAP2 */
+ #elif defined(CONFIG_ARCH_OMAP2420) || defined (CONFIG_ARM_OMAP2430)
+ #define __ipipe_mach_pic_mute omap2_intc_mute
+ #define __ipipe_mach_pic_unmute omap2_intc_unmute
+ 
+ /* OMAP3 */
+ #elif defined(CONFIG_ARCH_OMAP3)
+ #define __ipipe_mach_pic_mute omap3_intc_mute
+ #define __ipipe_mach_pic_unmute omap3_intc_unmute
+ 
+ /* OMAP4 */
+ #elif defined(CONFIG_ARCH_OMAP4)
+ #define __ipipe_mach_pic_mute gic_mute
+ #define __ipipe_mach_pic_unmute gic_unmute
+ #endif /* OMAP4 */
+ 
+ void __ipipe_mach_enable_irqdesc(struct ipipe_domain *ipd, unsigned irq)
+ {
+ 	struct irq_desc *desc = irq_to_desc(irq);
+ 	struct irq_data *idata = irq_desc_get_irq_data(desc);
+ 	struct irq_chip *chip = irq_data_get_irq_chip(idata);
+ 
+ 	if (chip == &gpio_irq_chip
+ #ifdef CONFIG_ARCH_OMAP1
+ 	    || desc->chip == &mpuio_irq_chip
+ #endif
+ 	    ) {
+ 		/* It is a gpio. */
+ 		struct gpio_bank *bank = irq_data_get_irq_chip_data(idata);
+ 
+ 		if (ipd != &ipipe_root) {
+ 			bank->nonroot_gpios |= (1 << (irq % 32));
+ 			if (bank->nonroot_gpios == (1 << (irq % 32))) {
+ 				__ipipe_irqbits[(bank->irq / 32)]
+ 					&= ~(1 << (bank->irq % 32));
+ 				__ipipe_mach_pic_set_irq_prio(bank->irq, 1);
+ 			}
+ 		}
+ 	} else
+ 		__ipipe_mach_pic_set_irq_prio(irq, ipd != &ipipe_root);
+ }
+ 
+ void __ipipe_mach_disable_irqdesc(struct ipipe_domain *ipd, unsigned irq)
+ {
+ 	struct irq_desc *desc = irq_to_desc(irq);
+ 	struct irq_data *idata = irq_desc_get_irq_data(desc);
+ 	struct irq_chip *chip = irq_data_get_irq_chip(idata);
+ 
+ 	if (chip == &gpio_irq_chip
+ #ifdef CONFIG_ARCH_OMAP1
+ 	    || desc->chip == &mpuio_irq_chip
+ #endif
+ 	    ) {
+ 		/* It is a gpio. */
+ 		struct gpio_bank *bank = irq_data_get_irq_chip_data(idata);
+ 
+ 		if (ipd != &ipipe_root) {
+ 			bank->nonroot_gpios &= ~(1 << (irq % 32));
+ 			if (!bank->nonroot_gpios) {
+ 				__ipipe_mach_pic_set_irq_prio(bank->irq, 0);
+ 				__ipipe_irqbits[(bank->irq / 32)]
+ 					|= (1 << (bank->irq % 32));
+ 			}
+ 		}
+ 	} else if (ipd != &ipipe_root)
+ 		__ipipe_mach_pic_set_irq_prio(irq, 0);
+ }
+ 
+ void ipipe_mute_pic(void)
+ {
+ 	unsigned muted;
+ 	unsigned i;
+ 
+ 	__ipipe_mach_pic_mute();
+ 
+ 	for (i = 0; i < gpio_bank_count; i++) {
+ 		struct gpio_bank *bank = &gpio_bank[i];
+ 		if (!bank->nonroot_gpios)
+ 			continue;
+ 
+ 		muted = __ipipe_irqbits[IH_GPIO_BASE / 32 + i];
+ 		if (muted)
+ 			muted &= _get_gpio_irqbank_mask(bank);
+ 		__raw_get_cpu_var(__ipipe_muted_irqs)[IH_GPIO_BASE / 32 + i] = muted;
+ 		if (muted)
+ 			_enable_gpio_irqbank(bank, muted, 0);
+ 	}
+ }
+ 
+ void ipipe_unmute_pic(void)
+ {
+ 	unsigned muted;
+ 	unsigned i;
+ 
+ 	for (i = 0; i < gpio_bank_count; i++) {
+ 		struct gpio_bank *bank = &gpio_bank[i];
+ 		if (!bank->nonroot_gpios)
+ 			continue;
+ 
+ 		muted = __raw_get_cpu_var(__ipipe_muted_irqs)[IH_GPIO_BASE / 32 + i];
+ 		if (muted)
+ 			_enable_gpio_irqbank(bank, muted, 1);
+ 	}
+ 
+ 	__ipipe_mach_pic_unmute();
+ }
+ #endif /* CONFIG_IPIPE && __IPIPE_FEATURE_PIC_MUTE */
+ 
  #if defined(CONFIG_ARCH_OMAP16XX) || defined(CONFIG_ARCH_OMAP2PLUS)
  static int omap_gpio_suspend(void)
  {
