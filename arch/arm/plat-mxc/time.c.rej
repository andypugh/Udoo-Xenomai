***************
*** 25,30 ****
  #include <linux/irq.h>
  #include <linux/clockchips.h>
  #include <linux/clk.h>
  
  #include <mach/hardware.h>
  #include <asm/sched_clock.h>
--- 25,31 ----
  #include <linux/irq.h>
  #include <linux/clockchips.h>
  #include <linux/clk.h>
+ #include <linux/ipipe.h>
  
  #include <mach/hardware.h>
  #include <asm/sched_clock.h>
***************
*** 67,72 ****
  #define timer_is_v1()	(cpu_is_mx1() || cpu_is_mx21() || cpu_is_mx27())
  #define timer_is_v2()	(!timer_is_v1())
  
  static struct clock_event_device clockevent_mxc;
  static enum clock_event_mode clockevent_mode = CLOCK_EVT_MODE_UNUSED;
  
--- 68,86 ----
  #define timer_is_v1()	(cpu_is_mx1() || cpu_is_mx21() || cpu_is_mx27())
  #define timer_is_v2()	(!timer_is_v1())
  
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ int __ipipe_mach_timerint;
+ EXPORT_SYMBOL(__ipipe_mach_timerint);
+ 
+ int __ipipe_mach_timerstolen = 0;
+ EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+ 
+ unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+ EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+ 
+ static unsigned mxc_min_delay;
+ #endif /* CONFIG_IPIPE && !CONFIG_SMP */
+ 
  static struct clock_event_device clockevent_mxc;
  static enum clock_event_mode clockevent_mode = CLOCK_EVT_MODE_UNUSED;
  
***************
*** 238,243 ****
  static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
  {
  	struct clock_event_device *evt = &clockevent_mxc;
  	uint32_t tstat;
  
  	if (timer_is_v2())
--- 252,258 ----
  static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
  {
  	struct clock_event_device *evt = &clockevent_mxc;
+ #if !defined(CONFIG_IPIPE) || defined(CONFIG_SMP)
  	uint32_t tstat;
  
  	if (timer_is_v2())
***************
*** 246,251 ****
  		tstat = __raw_readl(timer_base + MX1_2_TSTAT);
  
  	gpt_irq_acknowledge();
  
  	evt->event_handler(evt);
  
--- 261,269 ----
  		tstat = __raw_readl(timer_base + MX1_2_TSTAT);
  
  	gpt_irq_acknowledge();
+ #else /* CONFIG_IPIPE && !CONFIG_SMP */
+ 	__ipipe_tsc_update();
+ #endif /* CONFIG_IPIPE && !CONFIG_SMP */
  
  	evt->event_handler(evt);
  
***************
*** 288,294 ****
  	return 0;
  }
  
- void __init mxc_timer_init(struct clk *timer_clk, void __iomem *base, int irq)
  {
  	uint32_t tctl_val;
  
--- 306,372 ----
  	return 0;
  }
  
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ static struct __ipipe_tscinfo tsc_info = {
+ 	.type = IPIPE_TSC_TYPE_FREERUNNING,
+ 	.u = {
+ 		{
+ 			.mask = 0xffffffff,
+ 		},
+ 	},
+ };
+ 
+ int __ipipe_check_tickdev(const char *devname)
+ {
+ 	return !strcmp(devname, clockevent_mxc.name);
+ }
+ 
+ void __ipipe_mach_acktimer(void)
+ {
+ 	uint32_t tstat;
+ 
+ 	if (timer_is_v2())
+ 		tstat = __raw_readl(timer_base + V2_TSTAT);
+ 	else
+ 		tstat = __raw_readl(timer_base + MX1_2_TSTAT);
+ 
+ 	gpt_irq_acknowledge();
+ }
+ /*
+  * Reprogram the timer
+  */
+ 
+ void __ipipe_mach_set_dec(unsigned long delay)
+ {
+ 	if (delay <= mxc_min_delay
+ 	    || (!timer_is_v2() && mx1_2_set_next_event(delay, NULL) < 0)
+ 	    || (timer_is_v2() && v2_set_next_event(delay, NULL) < 0))
+ 		ipipe_trigger_irq(__ipipe_mach_timerint);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_set_dec);
+ 
+ void __ipipe_mach_release_timer(void)
+ {
+ 	mxc_set_mode(clockevent_mxc.mode, &clockevent_mxc);
+ 	if (clockevent_mxc.mode == CLOCK_EVT_MODE_ONESHOT)
+ 		clockevent_mxc.set_next_event(LATCH, &clockevent_mxc);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_release_timer);
+ 
+ unsigned long __ipipe_mach_get_dec(void)
+ {
+ 	if (!timer_is_v2())
+ 		return __raw_readl(timer_base + MX1_2_TCMP)
+ 			- __raw_readl(timer_base + MX1_2_TCN);
+ 	else
+ 		return __raw_readl(timer_base + V2_TCMP)
+ 			- __raw_readl(timer_base + V2_TCN);
+ }
+ #endif /* CONFIG_IPIPE && !CONFIG_SMP */
+ 
+ void __init
+ mxc_timer_init(struct clk *timer_clk,
+ 	       void __iomem *base, unsigned long phys, int irq)
  {
  	uint32_t tctl_val;
  
***************
*** 316,319 ****
  
  	/* Make irqs happen */
  	setup_irq(irq, &mxc_timer_irq);
  }
--- 394,413 ----
  
  	/* Make irqs happen */
  	setup_irq(irq, &mxc_timer_irq);
+ 
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ 	__ipipe_mach_timerint = irq;
+ 	__ipipe_mach_ticks_per_jiffy = (clk_get_rate(timer_clk) + HZ / 2) / HZ;
+ 	tsc_info.freq = clk_get_rate(timer_clk);
+ 	mxc_min_delay = 2 * ((__ipipe_cpu_freq + 500000) / 1000000) ?: 1;
+ 
+ 	if (timer_is_v1()) {
+ 		tsc_info.u.counter_paddr = phys + MX1_2_TCN;
+ 		tsc_info.counter_vaddr =(unsigned long)(timer_base + MX1_2_TCN);
+ 	} else {
+ 		tsc_info.u.counter_paddr = phys + V2_TCN;
+ 		tsc_info.counter_vaddr = (unsigned long)(timer_base + V2_TCN);
+ 	}
+ 	__ipipe_tsc_register(&tsc_info);
+ #endif /* CONFIG_IPIPE && !CONFIG_SMP */
  }
