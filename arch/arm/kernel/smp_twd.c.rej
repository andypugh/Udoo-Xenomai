--- arch/arm/kernel/smp_twd.c
+++ arch/arm/kernel/smp_twd.c
@@ -18,6 +18,7 @@
 #include <linux/irq.h>
 #include <linux/io.h>
 #include <linux/clk.h>
+#include <linux/cpufreq.h>
 #include <linux/err.h>
 #include <linux/ipipe.h>
 
@@ -30,6 +31,8 @@
 
 static unsigned long twd_timer_rate;
 
+static struct clock_event_device __percpu **twd_evt;
+
 #if defined(CONFIG_IPIPE) && defined(CONFIG_SMP)
 void __iomem *gt_base;
 
@@ -185,15 +188,18 @@
 		ctrl = TWD_TIMER_CONTROL_ENABLE | TWD_TIMER_CONTROL_IT_ENABLE
 			| TWD_TIMER_CONTROL_PERIODIC;
 		__raw_writel((twd_timer_rate + HZ / 2) / HZ, twd_base + TWD_TIMER_LOAD);
+		gic_enable_ppi(clk->irq);
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:
 		/* period set, and timer enabled in 'next_event' hook */
 		ctrl = TWD_TIMER_CONTROL_IT_ENABLE | TWD_TIMER_CONTROL_ONESHOT;
+		gic_enable_ppi(clk->irq);
 		break;
 	case CLOCK_EVT_MODE_UNUSED:
 	case CLOCK_EVT_MODE_SHUTDOWN:
 	default:
 		ctrl = 0;
+		gic_disable_ppi(clk->irq);
 	}
 
 	__raw_writel(ctrl, twd_base + TWD_TIMER_CONTROL);
@@ -215,6 +221,60 @@
 	return 0;
 }
 
+static struct clk *twd_get_clock(void)
+{
+	return clk_get_sys("smp_twd", NULL);
+}
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * Updates clockevent frequency when the cpu frequency changes.
+ * Called on the cpu that is changing frequency with interrupts disabled.
+ */
+static void twd_update_frequency(void *data)
+{
+	twd_timer_rate = clk_get_rate(twd_clk);
+
+	clockevents_update_freq(*__this_cpu_ptr(twd_evt), twd_timer_rate);
+}
+
+static int twd_cpufreq_transition(struct notifier_block *nb,
+	unsigned long state, void *data)
+{
+	struct cpufreq_freqs *freqs = data;
+
+	/*
+	 * The twd clock events must be reprogrammed to account for the new
+	 * frequency.  The timer is local to a cpu, so cross-call to the
+	 * changing cpu.
+	 *
+	 * Only wait for it to finish, if the cpu is active to avoid
+	 * deadlock when cpu1 is spinning on while(!cpu_active(cpu1)) during
+	 * booting of that cpu.
+	 */
+	if (state == CPUFREQ_POSTCHANGE || state == CPUFREQ_RESUMECHANGE)
+		smp_call_function_single(freqs->cpu, twd_update_frequency,
+					 NULL, cpu_active(freqs->cpu));
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block twd_cpufreq_nb = {
+	.notifier_call = twd_cpufreq_transition,
+};
+
+static int twd_cpufreq_init(void)
+{
+	if (twd_evt && *__this_cpu_ptr(twd_evt) && !IS_ERR(twd_clk))
+		return cpufreq_register_notifier(&twd_cpufreq_nb,
+			CPUFREQ_TRANSITION_NOTIFIER);
+
+	return 0;
+}
+core_initcall(twd_cpufreq_init);
+
+#endif
+
 static void __cpuinit twd_calibrate_rate(void)
 {
 	unsigned long count;
@@ -259,19 +319,21 @@
  */
 void __cpuinit twd_timer_setup(struct clock_event_device *clk)
 {
-	if (twd_clk == NULL) {
-		twd_clk = clk_get(NULL, "smp_twd");
-		if (IS_ERR(twd_clk))
-			pr_warn("%s: no clock found\n", __func__);
-		else
-			clk_enable(twd_clk);
+	struct clock_event_device **this_cpu_clk;
+
+	if (!twd_evt) {
+		twd_evt = alloc_percpu(struct clock_event_device *);
+		if (!twd_evt) {
+			pr_err("twd: can't allocate memory\n");
+			return;
+		}
+
+		if (!twd_clk)
+			twd_clk = twd_get_clock();
 
-		if (!IS_ERR(twd_clk)) {
+		if (!IS_ERR_OR_NULL(twd_clk))
 			twd_timer_rate = clk_get_rate(twd_clk);
-			printk(KERN_INFO "local timer: %lu.%02luMHz.\n",
-			       twd_timer_rate / 1000000,
-			       (twd_timer_rate / 10000) % 100);
-		} else
+		else
 			twd_calibrate_rate();
 
 		ipipe_twd_update_freq();
@@ -283,13 +345,13 @@
 	clk->rating = 350;
 	clk->set_mode = twd_set_mode;
 	clk->set_next_event = twd_set_next_event;
-	clk->shift = 20;
-	clk->mult = div_sc(twd_timer_rate, NSEC_PER_SEC, clk->shift);
-	clk->max_delta_ns = clockevent_delta2ns(0xffffffff, clk);
-	clk->min_delta_ns = clockevent_delta2ns(0xf, clk);
+
+	this_cpu_clk = __this_cpu_ptr(twd_evt);
+	*this_cpu_clk = clk;
+
+	clockevents_config_and_register(clk, twd_timer_rate,
+					0xf, 0xffffffff);
 
 	/* Make sure our local interrupt controller has this enabled */
 	gic_enable_ppi(clk->irq);
-
-	clockevents_register_device(clk);
 }
