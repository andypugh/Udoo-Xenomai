***************
*** 15,20 ****
  #include <linux/sched.h>	/* just for sched_clock() - funny that */
  #include <linux/timex.h>
  #include <linux/clockchips.h>
  
  #include <asm/mach/time.h>
  #include <asm/sched_clock.h>
--- 15,21 ----
  #include <linux/sched.h>	/* just for sched_clock() - funny that */
  #include <linux/timex.h>
  #include <linux/clockchips.h>
+ #include <linux/ipipe.h>
  
  #include <asm/mach/time.h>
  #include <asm/sched_clock.h>
***************
*** 47,59 ****
  
  #define MIN_OSCR_DELTA 2
  
  static irqreturn_t sa1100_ost0_interrupt(int irq, void *dev_id)
  {
  	struct clock_event_device *c = dev_id;
  
  	/* Disarm the compare/match, signal the event. */
  	OIER &= ~OIER_E0;
  	OSSR = OSSR_M0;
  	c->event_handler(c);
  
  	return IRQ_HANDLED;
--- 48,87 ----
  
  #define MIN_OSCR_DELTA 2
  
+ #ifdef CONFIG_IPIPE
+ int __ipipe_mach_timerint = IRQ_OST0;
+ EXPORT_SYMBOL(__ipipe_mach_timerint);
+ 
+ int __ipipe_mach_timerstolen = 0;
+ EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+ 
+ unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+ EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+ 
+ static struct __ipipe_tscinfo tsc_info = {
+ 	.type = IPIPE_TSC_TYPE_FREERUNNING,
+ 	.freq = CLOCK_TICK_RATE,
+ 	.counter_vaddr = io_p2v(0x90000010UL),
+ 	.u = {
+ 		{
+ 			.counter_paddr = 0x90000010UL,
+ 			.mask = 0xffffffff,
+ 		},
+ 	},
+ };
+ #endif /* CONFIG_IPIPE */
+ 
  static irqreturn_t sa1100_ost0_interrupt(int irq, void *dev_id)
  {
  	struct clock_event_device *c = dev_id;
  
  	/* Disarm the compare/match, signal the event. */
+ #ifndef CONFIG_IPIPE
  	OIER &= ~OIER_E0;
  	OSSR = OSSR_M0;
+ #else /* CONFIG_IPIPE */
+ 	__ipipe_tsc_update();
+ #endif /* CONFIG_IPIPE */
  	c->event_handler(c);
  
  	return IRQ_HANDLED;
***************
*** 97,102 ****
  	.set_mode	= sa1100_osmr0_set_mode,
  };
  
  static struct irqaction sa1100_timer_irq = {
  	.name		= "ost0",
  	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
--- 125,137 ----
  	.set_mode	= sa1100_osmr0_set_mode,
  };
  
+ #ifdef CONFIG_IPIPE
+ int __ipipe_check_tickdev(const char *devname)
+ {
+ 	return !strcmp(devname, ckevt_sa1100_osmr0.name);
+ }
+ #endif /* CONFIG_IPIPE */
+ 
  static struct irqaction sa1100_timer_irq = {
  	.name		= "ost0",
  	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
***************
*** 123,128 ****
  
  	clocksource_mmio_init(&OSCR, "oscr", CLOCK_TICK_RATE, 200, 32,
  		clocksource_mmio_readl_up);
  	clockevents_register_device(&ckevt_sa1100_osmr0);
  }
  
--- 158,167 ----
  
  	clocksource_mmio_init(&OSCR, "oscr", CLOCK_TICK_RATE, 200, 32,
  		clocksource_mmio_readl_up);
+ #ifdef CONFIG_IPIPE
+ 	__ipipe_tsc_register(&tsc_info);
+ #endif /* CONFIG_IPIPE */
+ 
  	clockevents_register_device(&ckevt_sa1100_osmr0);
  }
  
***************
*** 162,164 ****
  	.suspend	= sa1100_timer_suspend,
  	.resume		= sa1100_timer_resume,
  };
--- 201,238 ----
  	.suspend	= sa1100_timer_suspend,
  	.resume		= sa1100_timer_resume,
  };
+ 
+ #ifdef CONFIG_IPIPE
+ void __ipipe_mach_acktimer(void)
+ {
+ 	OSSR = OSSR_M0;  /* Clear match on timer 0 */
+ 	OIER &= ~OIER_E0;
+ }
+ 
+ /*
+  * Reprogram the timer
+  */
+ 
+ void __ipipe_mach_set_dec(unsigned long delay)
+ {
+ 	if (delay > MIN_OSCR_DELTA) {
+ 		OSMR0 = delay + OSCR;
+ 		OIER |= OIER_E0;
+ 	} else
+ 		ipipe_trigger_irq(IRQ_OST0);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_set_dec);
+ 
+ void __ipipe_mach_release_timer(void)
+ {
+ 	sa1100_osmr0_set_mode(ckevt_sa1100_osmr0.mode, &ckevt_sa1100_osmr0);
+ 	if (ckevt_sa1100_osmr0.mode == CLOCK_EVT_MODE_ONESHOT)
+ 		sa1100_osmr0_set_next_event(LATCH, &ckevt_sa1100_osmr0);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_release_timer);
+ 
+ unsigned long __ipipe_mach_get_dec(void)
+ {
+ 	return OSMR0 - OSCR;
+ }
+ #endif /* CONFIG_IPIPE */
