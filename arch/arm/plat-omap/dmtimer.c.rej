***************
*** 37,42 ****
  #include <linux/delay.h>
  #include <linux/io.h>
  #include <linux/module.h>
  #include <mach/hardware.h>
  #include <plat/dmtimer.h>
  #include <mach/irqs.h>
--- 37,43 ----
  #include <linux/delay.h>
  #include <linux/io.h>
  #include <linux/module.h>
+ #include <linux/sched.h>
  #include <mach/hardware.h>
  #include <plat/dmtimer.h>
  #include <mach/irqs.h>
***************
*** 328,334 ****
  	}
  }
  
- static void omap_dm_timer_reset(struct omap_dm_timer *timer)
  {
  	u32 l;
  
--- 329,335 ----
  	}
  }
  
+ static void omap_dm_timer_reset(struct omap_dm_timer *timer, int posted)
  {
  	u32 l;
  
***************
*** 339,350 ****
  	omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);
  
  	l = omap_dm_timer_read_reg(timer, OMAP_TIMER_OCP_CFG_REG);
  	l |= 0x02 << 3;  /* Set to smart-idle mode */
- 	l |= 0x2 << 8;   /* Set clock activity to perserve f-clock on idle */
  
  	/* Enable autoidle on OMAP2 / OMAP3 */
  	if (cpu_is_omap24xx() || cpu_is_omap34xx())
  		l |= 0x1 << 0;
  
  	/*
  	 * Enable wake-up on OMAP2 CPUs.
--- 340,356 ----
  	omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);
  
  	l = omap_dm_timer_read_reg(timer, OMAP_TIMER_OCP_CFG_REG);
+ #if !defined(CONFIG_IPIPE)
  	l |= 0x02 << 3;  /* Set to smart-idle mode */
+ 	l |= 0x2 << 8;   /* Set clock activity to perserve f-clock on
+ 			  * idle */
  
  	/* Enable autoidle on OMAP2 / OMAP3 */
  	if (cpu_is_omap24xx() || cpu_is_omap34xx())
  		l |= 0x1 << 0;
+ #else /* IPIPE */
+ 	l = (0x3 << 8) | (l & (1 << 5)) | (0x1 << 3) | (l & (1 << 2));
+ #endif /* IPIPE */
  
  	/*
  	 * Enable wake-up on OMAP2 CPUs.
***************
*** 355,368 ****
  
  	/* Match hardware reset default of posted mode */
  	omap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG,
- 			OMAP_TIMER_CTRL_POSTED);
- 	timer->posted = 1;
  }
  
- static void omap_dm_timer_prepare(struct omap_dm_timer *timer)
  {
  	omap_dm_timer_enable(timer);
- 	omap_dm_timer_reset(timer);
  }
  
  struct omap_dm_timer *omap_dm_timer_request(void)
--- 361,374 ----
  
  	/* Match hardware reset default of posted mode */
  	omap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG,
+ 				posted ? OMAP_TIMER_CTRL_POSTED : 0);
+ 	timer->posted = posted;
  }
  
+ static void omap_dm_timer_prepare(struct omap_dm_timer *timer, int posted)
  {
  	omap_dm_timer_enable(timer);
+ 	omap_dm_timer_reset(timer, posted);
  }
  
  struct omap_dm_timer *omap_dm_timer_request(void)
***************
*** 383,395 ****
  	spin_unlock_irqrestore(&dm_timer_lock, flags);
  
  	if (timer != NULL)
- 		omap_dm_timer_prepare(timer);
  
  	return timer;
  }
  EXPORT_SYMBOL_GPL(omap_dm_timer_request);
  
- struct omap_dm_timer *omap_dm_timer_request_specific(int id)
  {
  	struct omap_dm_timer *timer;
  	unsigned long flags;
--- 389,402 ----
  	spin_unlock_irqrestore(&dm_timer_lock, flags);
  
  	if (timer != NULL)
+ 		omap_dm_timer_prepare(timer, 1);
  
  	return timer;
  }
  EXPORT_SYMBOL_GPL(omap_dm_timer_request);
  
+ static struct omap_dm_timer *
+ omap_dm_timer_request_specific_inner(int id, int posted)
  {
  	struct omap_dm_timer *timer;
  	unsigned long flags;
***************
*** 407,422 ****
  	timer->reserved = 1;
  	spin_unlock_irqrestore(&dm_timer_lock, flags);
  
- 	omap_dm_timer_prepare(timer);
  
  	return timer;
  }
  EXPORT_SYMBOL_GPL(omap_dm_timer_request_specific);
  
  void omap_dm_timer_free(struct omap_dm_timer *timer)
  {
  	omap_dm_timer_enable(timer);
- 	omap_dm_timer_reset(timer);
  	omap_dm_timer_disable(timer);
  
  	WARN_ON(!timer->reserved);
--- 414,439 ----
  	timer->reserved = 1;
  	spin_unlock_irqrestore(&dm_timer_lock, flags);
  
+ 	omap_dm_timer_prepare(timer, posted);
  
  	return timer;
  }
+ struct omap_dm_timer *omap_dm_timer_request_specific(int id)
+ {
+ 	return omap_dm_timer_request_specific_inner(id, 1);
+ }
  EXPORT_SYMBOL_GPL(omap_dm_timer_request_specific);
  
+ struct omap_dm_timer *omap_dm_timer_request_specific_nonposted(int id)
+ {
+ 	return omap_dm_timer_request_specific_inner(id, 0);
+ }
+ EXPORT_SYMBOL_GPL(omap_dm_timer_request_specific_nonposted);
+ 
  void omap_dm_timer_free(struct omap_dm_timer *timer)
  {
  	omap_dm_timer_enable(timer);
+ 	omap_dm_timer_reset(timer, 1);
  	omap_dm_timer_disable(timer);
  
  	WARN_ON(!timer->reserved);
***************
*** 462,467 ****
  }
  EXPORT_SYMBOL_GPL(omap_dm_timer_get_irq);
  
  #if defined(CONFIG_ARCH_OMAP1)
  
  /**
--- 479,496 ----
  }
  EXPORT_SYMBOL_GPL(omap_dm_timer_get_irq);
  
+ #ifdef CONFIG_IPIPE
+ unsigned long omap_dm_timer_get_phys_counter_addr(struct omap_dm_timer *timer)
+ {
+ 	return timer->phys_base + (OMAP_TIMER_COUNTER_REG & 0xff);
+ }
+ 
+ unsigned long omap_dm_timer_get_virt_counter_addr(struct omap_dm_timer *timer)
+ {
+ 	return (unsigned long)timer->io_base + (OMAP_TIMER_COUNTER_REG & 0xff);
+ }
+ #endif /* CONFIG_IPIPE */
+ 
  #if defined(CONFIG_ARCH_OMAP1)
  
  /**
***************
*** 579,584 ****
  
  	clk_disable(timer->fclk);
  	ret = clk_set_parent(timer->fclk, dm_source_clocks[source]);
  	clk_enable(timer->fclk);
  
  	/*
--- 608,614 ----
  
  	clk_disable(timer->fclk);
  	ret = clk_set_parent(timer->fclk, dm_source_clocks[source]);
+ 	clk_enable(dm_source_clocks[source]);
  	clk_enable(timer->fclk);
  
  	/*
***************
*** 612,618 ****
  
  /* Optimized set_load which removes costly spin wait in timer_start */
  void omap_dm_timer_set_load_start(struct omap_dm_timer *timer, int autoreload,
-                             unsigned int load)
  {
  	u32 l;
  
--- 642,648 ----
  
  /* Optimized set_load which removes costly spin wait in timer_start */
  void omap_dm_timer_set_load_start(struct omap_dm_timer *timer, int autoreload,
+ 			    unsigned int load)
  {
  	u32 l;
  
