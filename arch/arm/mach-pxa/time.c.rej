***************
*** 24,29 ****
  #include <asm/sched_clock.h>
  #include <mach/regs-ost.h>
  
  /*
   * This is PXA's sched_clock implementation. This has a resolution
   * of at least 308 ns and a maximum value of 208 days.
--- 24,51 ----
  #include <asm/sched_clock.h>
  #include <mach/regs-ost.h>
  
+ #ifdef CONFIG_IPIPE
+ int __ipipe_mach_timerint = IRQ_OST0;
+ EXPORT_SYMBOL(__ipipe_mach_timerint);
+ 
+ int __ipipe_mach_timerstolen = 0;
+ EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+ 
+ unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+ EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+ 
+ static struct __ipipe_tscinfo tsc_info = {
+ 	.type = IPIPE_TSC_TYPE_FREERUNNING,
+ 	.counter_vaddr = io_p2v(0x40A00010UL),
+ 	.u = {
+ 		{
+ 			.counter_paddr = 0x40A00010UL,
+ 			.mask = 0xffffffff,
+ 		},
+ 	},
+ };
+ #endif /* CONFIG_IPIPE */
+ 
  /*
   * This is PXA's sched_clock implementation. This has a resolution
   * of at least 308 ns and a maximum value of 208 days.
***************
*** 55,62 ****
  	struct clock_event_device *c = dev_id;
  
  	/* Disarm the compare/match, signal the event. */
  	OIER &= ~OIER_E0;
  	OSSR = OSSR_M0;
  	c->event_handler(c);
  
  	return IRQ_HANDLED;
--- 77,88 ----
  	struct clock_event_device *c = dev_id;
  
  	/* Disarm the compare/match, signal the event. */
+ #ifndef CONFIG_IPIPE
  	OIER &= ~OIER_E0;
  	OSSR = OSSR_M0;
+ #else /* CONFIG_IPIPE */
+ 	__ipipe_tsc_update();
+ #endif /* CONFIG_IPIPE */
  	c->event_handler(c);
  
  	return IRQ_HANDLED;
***************
*** 67,74 ****
  {
  	unsigned long next, oscr;
  
- 	OIER |= OIER_E0;
  	next = OSCR + delta;
  	OSMR0 = next;
  	oscr = OSCR;
  
--- 93,100 ----
  {
  	unsigned long next, oscr;
  
  	next = OSCR + delta;
+ 	OIER |= OIER_E0;
  	OSMR0 = next;
  	oscr = OSCR;
  
***************
*** 105,110 ****
  	.set_mode	= pxa_osmr0_set_mode,
  };
  
  static struct irqaction pxa_ost0_irq = {
  	.name		= "ost0",
  	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
--- 131,176 ----
  	.set_mode	= pxa_osmr0_set_mode,
  };
  
+ #ifdef CONFIG_IPIPE
+ int __ipipe_check_tickdev(const char *devname)
+ {
+ 	return !strcmp(devname, ckevt_pxa_osmr0.name);
+ }
+ 
+ void __ipipe_mach_acktimer(void)
+ {
+ 	OSSR = OSSR_M0;  /* Clear match on timer 0 */
+ 	OIER &= ~OIER_E0;
+ }
+ 
+ /*
+  * Reprogram the timer
+  */
+ 
+ void __ipipe_mach_set_dec(unsigned long delay)
+ {
+ 	if (delay > MIN_OSCR_DELTA) {
+ 		OSMR0 = delay + OSCR;
+ 		OIER |= OIER_E0;
+ 	} else
+ 		ipipe_trigger_irq(IRQ_OST0);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_set_dec);
+ 
+ void __ipipe_mach_release_timer(void)
+ {
+ 	pxa_osmr0_set_mode(ckevt_pxa_osmr0.mode, &ckevt_pxa_osmr0);
+ 	if (ckevt_pxa_osmr0.mode == CLOCK_EVT_MODE_ONESHOT)
+ 		pxa_osmr0_set_next_event(LATCH, &ckevt_pxa_osmr0);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_release_timer);
+ 
+ unsigned long __ipipe_mach_get_dec(void)
+ {
+ 	return OSMR0 - OSCR;
+ }
+ #endif /* CONFIG_IPIPE */
+ 
  static struct irqaction pxa_ost0_irq = {
  	.name		= "ost0",
  	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
***************
*** 132,137 ****
  
  	clocksource_mmio_init(&OSCR, "oscr0", clock_tick_rate, 200, 32,
  		clocksource_mmio_readl_up);
  	clockevents_register_device(&ckevt_pxa_osmr0);
  }
  
--- 198,209 ----
  
  	clocksource_mmio_init(&OSCR, "oscr0", clock_tick_rate, 200, 32,
  		clocksource_mmio_readl_up);
+ 
+ #ifdef CONFIG_IPIPE
+ 	tsc_info.freq = clock_tick_rate;
+ 	__ipipe_tsc_register(&tsc_info);
+ #endif /* CONFIG_IPIPE */
+ 
  	clockevents_register_device(&ckevt_pxa_osmr0);
  }
  
