***************
*** 35,40 ****
  #include <linux/irq.h>
  #include <linux/clocksource.h>
  #include <linux/clockchips.h>
  
  #include <asm/mach/time.h>
  #include <plat/dmtimer.h>
--- 35,41 ----
  #include <linux/irq.h>
  #include <linux/clocksource.h>
  #include <linux/clockchips.h>
+ #include <linux/ipipe.h>
  
  #include <asm/mach/time.h>
  #include <plat/dmtimer.h>
***************
*** 54,66 ****
  static u8 __initdata gptimer_id = 1;
  static u8 __initdata inited;
  struct omap_dm_timer *gptimer_wakeup;
  
  static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
  {
- 	struct omap_dm_timer *gpt = (struct omap_dm_timer *)dev_id;
  	struct clock_event_device *evt = &clockevent_gpt;
  
  	omap_dm_timer_write_status(gpt, OMAP_TIMER_INT_OVERFLOW);
  
  	evt->event_handler(evt);
  	return IRQ_HANDLED;
--- 55,85 ----
  static u8 __initdata gptimer_id = 1;
  static u8 __initdata inited;
  struct omap_dm_timer *gptimer_wakeup;
+ #ifndef CONFIG_OMAP_32K_TIMER
+ static struct omap_dm_timer *gpt_clocksource;
+ #endif /* !CONFIG_OMAP_32K_TIMER */
+ 
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ int __ipipe_mach_timerint;
+ EXPORT_SYMBOL(__ipipe_mach_timerint);
+ 
+ unsigned int __ipipe_mach_ticks_per_jiffy;
+ EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+ 
+ int __ipipe_mach_timerstolen;
+ EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+ #endif /* CONFIG_IPIPE && !CONFIG_SMP */
  
  static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
  {
  	struct clock_event_device *evt = &clockevent_gpt;
+ #if !defined(CONFIG_IPIPE) || defined(CONFIG_SMP)
+ 	struct omap_dm_timer *gpt = (struct omap_dm_timer *)dev_id;
  
  	omap_dm_timer_write_status(gpt, OMAP_TIMER_INT_OVERFLOW);
+ #else /* CONFIG_IPIPE */
+ 	__ipipe_tsc_update();
+ #endif /* CONFIG_IPIPE */
  
  	evt->event_handler(evt);
  	return IRQ_HANDLED;
***************
*** 130,135 ****
  	return 0;
  }
  
  static void __init omap2_gp_clockevent_init(void)
  {
  	u32 tick_rate;
--- 149,172 ----
  	return 0;
  }
  
+ #ifdef CONFIG_IPIPE
+ static struct __ipipe_tscinfo __maybe_unused tsc_info = {
+ 	.type = IPIPE_TSC_TYPE_FREERUNNING,
+ 	.u = {
+ 		{
+ 			.mask = 0xffffffff,
+ 		},
+ 	},
+ };
+ 
+ #ifndef CONFIG_SMP
+ int __ipipe_check_tickdev(const char *devname)
+ {
+ 	return !strcmp(devname, clockevent_gpt.name);
+ }
+ #endif /* !CONFIG_SMP */
+ #endif /* CONFIG_IPIPE */
+ 
  static void __init omap2_gp_clockevent_init(void)
  {
  	u32 tick_rate;
***************
*** 141,147 ****
  	sprintf(clockevent_hwmod_name, "timer%d", gptimer_id);
  	omap_hwmod_setup_one(clockevent_hwmod_name);
  
- 	gptimer = omap_dm_timer_request_specific(gptimer_id);
  	BUG_ON(gptimer == NULL);
  	gptimer_wakeup = gptimer;
  
--- 178,184 ----
  	sprintf(clockevent_hwmod_name, "timer%d", gptimer_id);
  	omap_hwmod_setup_one(clockevent_hwmod_name);
  
+ 	gptimer = omap_dm_timer_request_specific_nonposted(gptimer_id);
  	BUG_ON(gptimer == NULL);
  	gptimer_wakeup = gptimer;
  
***************
*** 163,168 ****
  		gptimer_id, tick_rate);
  
  	omap2_gp_timer_irq.dev_id = (void *)gptimer;
  	setup_irq(omap_dm_timer_get_irq(gptimer), &omap2_gp_timer_irq);
  	omap_dm_timer_set_int_enable(gptimer, OMAP_TIMER_INT_OVERFLOW);
  
--- 200,211 ----
  		gptimer_id, tick_rate);
  
  	omap2_gp_timer_irq.dev_id = (void *)gptimer;
+ 
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ 	__ipipe_mach_timerint = omap_dm_timer_get_irq(gptimer);
+ 	__ipipe_mach_ticks_per_jiffy = (tick_rate + HZ / 2) / HZ;
+ #endif /* CONFIG_IPIPE && !CONFIG_SMP*/
+ 
  	setup_irq(omap_dm_timer_get_irq(gptimer), &omap2_gp_timer_irq);
  	omap_dm_timer_set_int_enable(gptimer, OMAP_TIMER_INT_OVERFLOW);
  
***************
*** 173,179 ****
  	clockevent_gpt.min_delta_ns =
  		clockevent_delta2ns(3, &clockevent_gpt);
  		/* Timer internal resynch latency. */
- 
  	clockevent_gpt.cpumask = cpumask_of(0);
  	clockevents_register_device(&clockevent_gpt);
  }
--- 216,221 ----
  	clockevent_gpt.min_delta_ns =
  		clockevent_delta2ns(3, &clockevent_gpt);
  		/* Timer internal resynch latency. */
  	clockevent_gpt.cpumask = cpumask_of(0);
  	clockevents_register_device(&clockevent_gpt);
  }
***************
*** 181,187 ****
  /* Clocksource code */
  
  #ifdef CONFIG_OMAP_32K_TIMER
- /* 
   * When 32k-timer is enabled, don't use GPTimer for clocksource
   * instead, just leave default clocksource which uses the 32k
   * sync counter.  See clocksource setup in plat-omap/counter_32k.c
--- 223,229 ----
  /* Clocksource code */
  
  #ifdef CONFIG_OMAP_32K_TIMER
+ /*
   * When 32k-timer is enabled, don't use GPTimer for clocksource
   * instead, just leave default clocksource which uses the 32k
   * sync counter.  See clocksource setup in plat-omap/counter_32k.c
***************
*** 198,204 ****
   */
  static DEFINE_CLOCK_DATA(cd);
  static struct omap_dm_timer *gpt_clocksource;
- static cycle_t clocksource_read_cycles(struct clocksource *cs)
  {
  	return (cycle_t)omap_dm_timer_read_counter(gpt_clocksource);
  }
--- 240,251 ----
   */
  static DEFINE_CLOCK_DATA(cd);
  static struct omap_dm_timer *gpt_clocksource;
+ static cycle_t notrace clocksource_read_dummy(struct clocksource *cs)
+ {
+        return 0;
+ }
+ 
+ static cycle_t notrace clocksource_read_cycles(struct clocksource *cs)
  {
  	return (cycle_t)omap_dm_timer_read_counter(gpt_clocksource);
  }
***************
*** 206,216 ****
  static struct clocksource clocksource_gpt = {
  	.name		= "gp timer",
  	.rating		= 300,
- 	.read		= clocksource_read_cycles,
  	.mask		= CLOCKSOURCE_MASK(32),
  	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
  };
  
  static void notrace dmtimer_update_sched_clock(void)
  {
  	u32 cyc;
--- 253,269 ----
  static struct clocksource clocksource_gpt = {
  	.name		= "gp timer",
  	.rating		= 300,
+ 	.read		= clocksource_read_dummy,
  	.mask		= CLOCKSOURCE_MASK(32),
  	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
  };
  
+ unsigned long long notrace sched_clock(void)
+ {
+        u32 cyc = clocksource_gpt.read(&clocksource_gpt);
+        return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+ }
+ 
  static void notrace dmtimer_update_sched_clock(void)
  {
  	u32 cyc;
***************
*** 229,236 ****
  		"%s: failed to request dm-timer\n";
  	static char err2[] __initdata = KERN_ERR
  		"%s: can't register clocksource!\n";
  
- 	gpt = omap_dm_timer_request();
  	if (!gpt)
  		printk(err1, clocksource_gpt.name);
  	gpt_clocksource = gpt;
--- 282,303 ----
  		"%s: failed to request dm-timer\n";
  	static char err2[] __initdata = KERN_ERR
  		"%s: can't register clocksource!\n";
+ 	char clocksource_hwmod_name[8]; /* 8 = sizeof("timerXX0") */
+ 
+ 
+ #if defined(CONFIG_IPIPE)
+ 	if (cpu_is_omap34xx()) {
+ 		sprintf(clocksource_hwmod_name, "timer%d", 3);
+ 		omap_hwmod_setup_one(clocksource_hwmod_name);
+ 		gpt = omap_dm_timer_request_specific(3);
+ 	} else
+ #endif /* CONFIG_IPIPE */
+ 		{
+ 			sprintf(clocksource_hwmod_name, "timer%d", 2);
+ 			omap_hwmod_setup_one(clocksource_hwmod_name);
+ 			gpt = omap_dm_timer_request();
+ 		}
  
  	if (!gpt)
  		printk(err1, clocksource_gpt.name);
  	gpt_clocksource = gpt;
***************
*** 240,249 ****
  
  	omap_dm_timer_set_load_start(gpt, 1, 0);
  
- 	init_sched_clock(&cd, dmtimer_update_sched_clock, 32, tick_rate);
  
  	if (clocksource_register_hz(&clocksource_gpt, tick_rate))
  		printk(err2, clocksource_gpt.name);
  }
  #endif
  
--- 307,326 ----
  
  	omap_dm_timer_set_load_start(gpt, 1, 0);
  
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ 	tsc_info.freq = tick_rate;
+ 	tsc_info.counter_vaddr =
+ 		omap_dm_timer_get_virt_counter_addr(gpt_clocksource);
+ 	tsc_info.u.counter_paddr =
+ 		omap_dm_timer_get_phys_counter_addr(gpt_clocksource);
+ 	__ipipe_tsc_register(&tsc_info);
+ #endif
  
  	if (clocksource_register_hz(&clocksource_gpt, tick_rate))
  		printk(err2, clocksource_gpt.name);
+ 
+ 	clocksource_gpt.read = &clocksource_read_cycles;
+ 	init_sched_clock(&cd, dmtimer_update_sched_clock, 32, tick_rate);
  }
  #endif
  
***************
*** 257,262 ****
  #endif
  	omap_dm_timer_init();
  
  	omap2_gp_clockevent_init();
  	omap2_gp_clocksource_init();
  }
--- 334,343 ----
  #endif
  	omap_dm_timer_init();
  
+ #ifdef CONFIG_IPIPE
+ 	if (cpu_is_omap34xx())
+ 		omap2_gp_clockevent_set_gptimer(2);
+ #endif
  	omap2_gp_clockevent_init();
  	omap2_gp_clocksource_init();
  }
***************
*** 264,266 ****
  struct sys_timer omap_timer = {
  	.init	= omap2_gp_timer_init,
  };
--- 345,382 ----
  struct sys_timer omap_timer = {
  	.init	= omap2_gp_timer_init,
  };
+ 
+ #if defined(CONFIG_IPIPE) && !defined(CONFIG_SMP)
+ void __ipipe_mach_acktimer(void)
+ {
+ 	omap_dm_timer_write_status(gptimer, OMAP_TIMER_INT_OVERFLOW);
+ 	omap_dm_timer_read_status(gptimer);
+ }
+ 
+ /*
+  * Reprogram the timer
+  */
+ 
+ void __ipipe_mach_set_dec(unsigned long delay)
+ {
+ 	if (delay > 3)
+ 		omap_dm_timer_set_load_start(gptimer, 0, 0xffffffff - delay);
+ 	else
+ 		ipipe_trigger_irq(__ipipe_mach_timerint);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_set_dec);
+ 
+ void __ipipe_mach_release_timer(void)
+ {
+ 	struct clock_event_device *ckdev = &clockevent_gpt;
+ 	ckdev->set_mode(ckdev->mode, ckdev);
+ 	if (ckdev->mode == CLOCK_EVT_MODE_ONESHOT)
+ 		ckdev->set_next_event(__ipipe_mach_ticks_per_jiffy, ckdev);
+ }
+ EXPORT_SYMBOL(__ipipe_mach_release_timer);
+ 
+ unsigned long __ipipe_mach_get_dec(void)
+ {
+ 	return 0xffffffff - omap_dm_timer_read_counter(gptimer);
+ }
+ #endif /* CONFIG_IPIPE */
