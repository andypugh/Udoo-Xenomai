***************
*** 15,20 ****
  #include <linux/interrupt.h>
  #include <linux/io.h>
  #include <mach/hardware.h>
  #include <asm/mach/irq.h>
  
  
--- 15,21 ----
  #include <linux/interrupt.h>
  #include <linux/io.h>
  #include <mach/hardware.h>
+ #include <asm/ipipe.h>
  #include <asm/mach/irq.h>
  
  
***************
*** 32,40 ****
  #define INTC_MIR_CLEAR0		0x0088
  #define INTC_MIR_SET0		0x008c
  #define INTC_PENDING_IRQ0	0x0098
  /* Number of IRQ state bits in each MIR register */
  #define IRQ_BITS_PER_REG	32
  
  /*
   * OMAP2 has a number of different interrupt controllers, each interrupt
   * controller is identified as its own "bank". Register definitions are
--- 33,48 ----
  #define INTC_MIR_CLEAR0		0x0088
  #define INTC_MIR_SET0		0x008c
  #define INTC_PENDING_IRQ0	0x0098
+ #define INTC_PRIO               0x0100
  /* Number of IRQ state bits in each MIR register */
  #define IRQ_BITS_PER_REG	32
  
+ #if !defined(MULTI_OMAP1) && !defined(MULTI_OMAP2)
+ #define inline_single inline
+ #else
+ #define inline_single
+ #endif
+ 
  /*
   * OMAP2 has a number of different interrupt controllers, each interrupt
   * controller is identified as its own "bank". Register definitions are
***************
*** 63,82 ****
  
  /* INTC bank register get/set */
  
- static void intc_bank_write_reg(u32 val, struct omap_irq_bank *bank, u16 reg)
  {
  	__raw_writel(val, bank->base_reg + reg);
  }
  
- static u32 intc_bank_read_reg(struct omap_irq_bank *bank, u16 reg)
  {
  	return __raw_readl(bank->base_reg + reg);
  }
  
  /* XXX: FIQ and additional INTC support (only MPU at the moment) */
- static void omap_ack_irq(struct irq_data *d)
  {
  	intc_bank_write_reg(0x1, &irq_banks[0], INTC_CONTROL);
  }
  
  static void omap_mask_ack_irq(struct irq_data *d)
--- 71,91 ----
  
  /* INTC bank register get/set */
  
+ static inline_single void intc_bank_write_reg(u32 val, struct omap_irq_bank *bank, u16 reg)
  {
  	__raw_writel(val, bank->base_reg + reg);
  }
  
+ static inline_single u32 intc_bank_read_reg(struct omap_irq_bank *bank, u16 reg)
  {
  	return __raw_readl(bank->base_reg + reg);
  }
  
  /* XXX: FIQ and additional INTC support (only MPU at the moment) */
+ static inline_single void omap_ack_irq(struct irq_data *d)
  {
  	intc_bank_write_reg(0x1, &irq_banks[0], INTC_CONTROL);
+ 	dsb();
  }
  
  static void omap_mask_ack_irq(struct irq_data *d)
***************
*** 101,108 ****
  	while (!(intc_bank_read_reg(bank, INTC_SYSSTATUS) & 0x1))
  		/* Wait for reset to complete */;
  
  	/* Enable autoidle */
  	intc_bank_write_reg(1 << 0, bank, INTC_SYSCONFIG);
  }
  
  int omap_irq_pending(void)
--- 110,124 ----
  	while (!(intc_bank_read_reg(bank, INTC_SYSSTATUS) & 0x1))
  		/* Wait for reset to complete */;
  
+ #ifndef CONFIG_IPIPE
  	/* Enable autoidle */
  	intc_bank_write_reg(1 << 0, bank, INTC_SYSCONFIG);
+ 	intc_bank_write_reg(0x2, bank, INTC_IDLE);
+ #else /* CONFIG_IPIPE */
+ 	/* Disable autoidle */
+ 	intc_bank_write_reg(0, bank, INTC_SYSCONFIG);
+ 	intc_bank_write_reg(0x1, bank, INTC_IDLE);
+ #endif /* CONFIG_IPIPE */
  }
  
  int omap_irq_pending(void)
***************
*** 132,137 ****
  	ct = gc->chip_types;
  	ct->chip.irq_ack = omap_mask_ack_irq;
  	ct->chip.irq_mask = irq_gc_mask_disable_reg;
  	ct->chip.irq_unmask = irq_gc_unmask_enable_reg;
  
  	ct->regs.ack = INTC_CONTROL;
--- 148,156 ----
  	ct = gc->chip_types;
  	ct->chip.irq_ack = omap_mask_ack_irq;
  	ct->chip.irq_mask = irq_gc_mask_disable_reg;
+ #ifdef CONFIG_IPIPE
+ 	ct->chip.irq_mask_ack = omap_mask_ack_irq;
+ #endif
  	ct->chip.irq_unmask = irq_gc_unmask_enable_reg;
  
  	ct->regs.ack = INTC_CONTROL;
***************
*** 181,186 ****
  	       nr_of_irqs, nr_banks, nr_banks > 1 ? "s" : "");
  }
  
  #ifdef CONFIG_ARCH_OMAP3
  static struct omap3_intc_regs intc_context[ARRAY_SIZE(irq_banks)];
  
--- 200,267 ----
  	       nr_of_irqs, nr_banks, nr_banks > 1 ? "s" : "");
  }
  
+ #if defined(CONFIG_IPIPE) && defined(__IPIPE_FEATURE_PIC_MUTE)
+ DECLARE_PER_CPU(__ipipe_irqbits_t, __ipipe_muted_irqs);
+ 
+ void omap3_intc_mute(void)
+ {
+ 	struct omap_irq_bank *bank = &irq_banks[0];
+ 
+ 	intc_bank_write_reg(0x1, bank, INTC_THRESHOLD);
+ 	intc_bank_write_reg(0x1, bank, INTC_CONTROL);
+ }
+ 
+ void omap3_intc_unmute(void)
+ {
+ 	struct omap_irq_bank *bank = &irq_banks[0];
+ 
+ 	intc_bank_write_reg(0xff, bank, INTC_THRESHOLD);
+ }
+ 
+ void omap3_intc_set_irq_prio(int irq, int hi)
+ {
+ 	struct omap_irq_bank *bank = &irq_banks[0];
+ 
+ 	if (irq >= INTCPS_NR_MIR_REGS * 32)
+ 		return;
+ 
+ 	intc_bank_write_reg(hi ? 0 : 0xfc, bank, INTC_PRIO + 4 * irq);
+ }
+ 
+ void omap2_intc_mute(void)
+ {
+ 	struct omap_irq_bank *bank = &irq_banks[0];
+ 	unsigned muted;
+ 	int i;
+ 
+ 	for (i = 0; i < INTCPS_NR_MIR_REGS; i++) {
+ 		muted = __ipipe_irqbits[i];
+ 		if (muted)
+ 			muted &= ~intc_bank_read_reg(bank,
+ 						     INTC_MIR0 + 0x20 * i);
+ 		__raw_get_cpu_var(__ipipe_muted_irqs)[i] = muted;
+ 		if (muted)
+ 			intc_bank_write_reg(muted, bank,
+ 					    INTC_MIR_SET0 + 0x20 * i);
+ 	}
+ 	intc_bank_write_reg(0x1, bank, INTC_CONTROL);
+ }
+ 
+ void omap2_intc_unmute(void)
+ {
+ 	struct omap_irq_bank *bank = &irq_banks[0];
+ 	unsigned muted;
+ 	int i;
+ 
+ 	for (i = 0; i < INTCPS_NR_MIR_REGS; i++) {
+ 		muted = __raw_get_cpu_var(__ipipe_muted_irqs)[i];
+ 		if (muted)
+ 			intc_bank_write_reg(muted, bank,
+ 					    INTC_MIR_CLEAR0 + 0x20 * i);
+ 	}
+ }
+ #endif /* __IPIPE_FEATURE_PIC_MUTE */
+ 
  #ifdef CONFIG_ARCH_OMAP3
  static struct omap3_intc_regs intc_context[ARRAY_SIZE(irq_banks)];
  
